--------------------------------------- FILESYSTEM HIERARCHY ---------------------------------------

directorio root => /

directorio con programas binarios necesarios para el sistema en boot y run => /bin
  - lenguaje de comandos => bash

directorio con programas binarios que realizan tareas vitales del sistema que son reservados para el usuario root => /sbin

directorio que contiene los programas para que se ejecuten los programas de /bin => /lib

directorio que contiene el kernel e imagenes iniciales de RAM => /boot
  - directorio con la configuración del gestor de arranque múltiple (grub) => /grub
    - archivo para configurar el boot loader => grub.conf

directorio que representa los dispositivos físicamente instalados en el ordenador, tratados como archivos => /dev
  - archivo para lanzar valores innecesarios => null

directorio con archivos de configuración del sistema, contiene los shell scripts que inician cada uno de los servicios del sistema en el boot => /etc
  - archivo donde se determinará cuando se ejecutarán los jobs => crontab
  - archivo donde se muestran los dispositivos de almacenamiento y puntos de montaje asociados => fstab
  - archivo con la lista de usuarios con su información => passwd

directorio que todos los usuarios tienen por defecto para proteger el sistema de actividades errantes de los usuarios => /home

directorio home para el usuario root => /root

directorio para la recuperación parcial de un evento corrupto del filesystem, únicamente cuando pase algo realmente malo en el sistema => /lost+found

directorio que contiene los puntos de montajes de media removibles, montados manualmente (sistemas de Linux antiguos) => /mnt

directorio que contiene los puntos de montajes de media removibles, son montados automáticamente al insertarse (sistemas de Linux modernos) => /media

directorio para instalación de software adicional, productos de software comerciales => /opt

directorio con archivos virtuales que reciben y envían información al kernel => /proc

directorio que almacena archivos de manera temporal => /tmp

directorio que contiene los programas de uso común para todos los usuarios => /usr
  - directorio con programas ejecutables instalados en la distribución => /bin
  - directorio con archivos compartidos para los programas /usr/bin => /lib
  - directorio con programas que no están incluidos en la distribución pero uso destinado para todo el sistema => /local
  - directorio con programas de administración del sistema => /sbin
  - directorio que contiene los datos compartidos usados en programas de /usr/bin, incluye archivos de configuración por defecto, íconos, etc. => /share
    - directorio con la documentación de los paquetes instalados => /doc

directorio para almacenar data estática como base de datos, spool files, correo de usuario, etc. => /var
  - directorio que contiene los logs files de programas del sistema => /log

--------------------------------------- COMMANDS ---------------------------------------

listar filesystem hierarchy => man hier

herramientas de redes => net-tools
  - instalar en Debian => apt-get install net-tools

cambiar el idioma del teclado => loadkeys idioma

ver las historia de los comandos => history

mostrar la fecha actual => date

mostrar el calendario del mes actual => cal

mostrar información de los ficheros => df

mostrar la memoria libre => free

cambiar de directorio => cd directorio
  - último directorio trabajado => cd -

listar los archivos y directorios => ls archivo directorio ...
  - mostrar todos los archivos incluyendo ocultos y directorios => ls -a|--all directorio
  - mostrar un formato de listado largo => ls -l directorio
    - primer campo, indica el tipo de archivo => - (archivo) | d (directorio) | l (symbolic link), los demás caracteres indican los permisos
    - segundo campo => número de hard links del directorio
    - tercer campo => nombre del propietario del archivo
    - cuarto campo => nombre del grupo al que pertenece el archivo
    - quinto campo => tamaño del archivo
    - sexto campo => fecha de última modificación del archivo
  - mostrar detalles sobre el directorio => ls -d|--directory directorio (usar con -l)
  - mostrar los directorios y archivos diferenciandolos => ls -F|--classify directorio (usar con -l)
  - mostrar el tamaño de los archivos de forma legible para la persona => ls -h|--human-readable directorio (usar con -l)
  - ordenar por la fecha de modificación, el más reciente primero => ls -t directorio
  - ordenar por el tamaño del archivo, más grande primero => ls -S directorio
  - ordenar al revés => ls -r|--reverse directorio
  - mostrar los inode numbers para reconocer si son los mismos archivos en un hard link => ls -i directorio

obtener el tipo de archivo => file archivo|directorio

ver un archivo con un pager => less archivo

crear links entre archivos => ln
  - crear un hard link => ln archivo nombre_link
  - crear un symbolic link => ln -s archivo nombre_link

copiar archivos => cp archivo|directorio destino
  - copiar archivo únicamente si no existe el archivo destino o si este no tiene modificaciones posteriores al archivo base  => cp -u|--update base destino
  - usar un prompt para indicar si sobreescribiremos con el archivo base al archivo destino => cp -i|--interactive base destino
  - recursivamente copiar los archivos de un directorio => cp -r|--recursive base destino
  - dar detalles de la copia del archivo => cp -v|--verbose base destino
  - copiar un archivo con todas sus características (usuario, grupo, permisos, ...) no solo el contenido => cp -a|--archive base destino

mover o cambiar el nombre de un archivo => mv base destino
  - mostrar un prompt cuando se mueve un archivo a un destino que ya existe => mv -i|--interactive base destino
  - mover archivo únicamente si no existe el archivo destino o si este no tiene modificaciones posteriores al archivo base  => mv -u|--update base destino
  - dar detalles del proceso => mv -v|--verbose base destino

remover archivos => rm archivo ...
  - utilizar un prompt para confirmar la eliminación => rm -i|--interactive archivo
  - eliminar directorio de manera recursiva => rm -r|--recursive directorio
  - forzar la eliminación del archivo, ignorando si no existe y el prompt de confirmación => rm -f|--force archivo
  - dar detalles de la eliminación => rm -v|--verbose archivo

crear directorios => mkdir directorio ...
  - crear un directorio dentro de directorios que aún no han sido creados => mkdir -p directorio

tipos de comandos =>
  - executable program => son todos los programas que se encuentran en /usr/bin, que han sido escritos en un lenguaje de scripting
  - shell builtins => comandos creados por el shell (comandos básicos)
  - shell functions => comandos creados por personalización
  - alias => comandos que nos permite llamar de diferente manera uno o varios comandos

obtener el tipo de comando => type comando

mostrar las primeras líneas de un archivo => head archivo
  - indicar cantidad de líneas que se mostrarán => head -n cantidad archivo

mostras las últimas lineas de un archivo => tail archivo
  - indicar cantidad de líneas que se mostrarán => tail -n cantidad archivo
  - hacer un monitoreo a los cambios del archivo => tail -f archivo

leer una entrada de archivos y escribirla en uno o más archivos sin interrumpir el pipeline => comando | tee archivo ... | continua pipeline

mostrar un manual del comando => man comando
  - mostrar las secciones de un comando => apropos comando | man -k comando
    - obtener descripciones de las secciones => whatis comando
  - ver la sección de un comando => man seccion comando

mostrar mediante info pages la información de un comando, con diferencia que posee links para poder movernos entre páginas => info comando

standards =>
  - el standard output tiene como descriptor al 1 en un comando mientras que el standard error el 2
  - redireccionando standard output =>
    - sobreescribiendo un archivo => entrada > archivo
    - añadiendo más líneas a un archivo => entrada >> archivo
    - escribir en un archivo mediante el teclado => > archivo
  - redireccionando standard error =>
    - sobreescribiendo un archivo => entrada 2> archivo
    - eliminando el standard error => entrada 2>/dev/null
  - redireccionando standard output y standard error =>
    - forma trandicional => entrada > archivo 2>&1
    - forma actual => entrada &> archivo


// TODO

imprimir una palabra o bytes de lineas de texto => wc
  - imprimir la cantidad de bytes => wc -c valor

reportar u omitir lineas repetidas =>
  - eliminar todos las lineas repetidas => ls archivo archivo | uniq
  - mostrar solamente las lineas repetidas => ls archivo archivo | uniq -d

imprimir en la pantalla => echo, todos los valores que tienen una funcionalidad son expansions
  - pathname expansion, mostrar todos los archivos de la carpeta actual con wildcards => echo wildcard
  - tilde expansion => echo ~nombre_usuario, el nombre_usuario es opcional, sino se utilizará al usuario actual
  - arithmetic expansion => echo $((operacion aritmetica))
  - brace expansion => es como un interador de todo el contenido del echo texto_{valor1, valor2, valor3} donde se imprimiria como texto_valor1 texto_valor2 texto_valor3
    también se puede utilizar con rangos => echo valor_{1..2} o valor_{A..Z}, se puede de menor a mayor en números y caracteres
  - parameter expansion => para mostrar los valores de las variables de entorno
  - command substitution => poner los comandos dentro de un comando
    comando $(comando | comando |...)
  - double quotes => nos permiten poder escribir nombres largos para archivos que tienen espacios en blancos, también quita los saltos de línea en el output
    - una forma de escapar de las expansions en double quotes es con un \
  - single quotes => nos permite escapar de todo tipo de de expansions

mostrar todas las variables de entorno => printenv

indicar que el programa espere => sleep tiempo_segundos

command line editing => bash usa la librería Readline
  - los términos que usa esta librería =>
    - killing = cutting
    - yanking = pasting
  - cursor movement commands =>
    - mover el cursor al inicio de la linea => CTRL + A
    - mover el cursor al final de la linea => CTRL + E
    - mover el cursor un caracter a la derecha => CTRL + F
    - mover el cursor un caracter a la izquierda => CTRL + B
    - mover el cursor una palabra a la derecha => ALT + F
    - mover el cursor una palabra a la izquierda => ALT + B
    - limpiar la console => CTRL + L
  - text editing comandos =>
    - eliminar a la derecha => CTRL + D
    - cambiar la letra anterior con la actual del cursor => CTRL + T
    - cambiar la palabra anterior con la actual del cursor => ALT + T
    - convertir la palabra que sigue en lowercase => ALT + L
    - convertir la palabra que sigue en uppercase => ALT + U

history => bash guarda los ultimos 500 comandos usados
  - indicar que linea del history usar comando => !linea
  - commandos =>
    - mover al comando previo => CTRL + P
    - mover al comando posterior => CTRL + N
    - mover al primer comando => ALT + <
    - mover al ultimo comando => ALT + >
    - buscar en el history => CTRL + R

los hosts que se agreguen en /etc/hosts serán puestos como https

permissions =>
  - mostrar la identidad del usuario actual => id
  - archivo que tiene las cuentas de usuario => /etc/passwd
  - archivo que tiene los grupos => /etc/group
  - cuando se crea un grupo o usuario los archivos anteriores cambian como en /etc/shadow que tiene las contraseñas
  - la práctica moderna de Linux para los grupos y usuarios es que un usuario solo pertenezca a un grupo y ese grupo tenga el mismo nombre que el usuario para facilitar la asignación
  - atributos del archivo => se separan en 10 caracteres
    - 1 caracter => indica el tipo del archivo
      - archivo regular => -
      - directorio => d
      - symbolic link, tiene valores de atributo del archivo al azar porque solo indica donde está el archivo con los permisos => l
      - character special file, se refiere a un device que maneja un flujo de bytes como un modem o un terminal => c
      - block special file, device que manejen bloques de datos como disco duro o cd-rom drive  => b
  - los restantes son atributos de permisos =>
    - del 2 al 4 => permisos del propietario
    - del 5 al 7 => permisos del grupo
    - del 7 al 9 => permisos mundiales
    - atributos de permisos =>
      - r =>
        - archivo => permite abrir y leer el archivo
        - directorio => permite listar el contenido del directorio
      - w =>
        - archivo => permite escribir o truncar el archivo, pero esto no permite que el archivo sea renombrado o eliminado
        - diretorio => permite a los archivos dentro del directorio puedan ser creados, eliminados y renombrados
      - x =>
        - archivo => permite que el archivo sea tratado como programa de ejecución (script)
        - directorio => permite que se ingrese al directorio (cd)
  - cambiar permisos del archivo => chmod, tiene dos formas distintas de hacer el cambio: representación octal numérica y representación symbolic
    - permisos de archivos en binario y octal
      octal     binario     modo archivo
      0         000         ---
      1         001         --x
      2         010         -w-
      3         011         -wx
      4         100         r--
      5         101         r-x
      6         110         rw-
      7         111         rwx
    - representación symbolic
      - representación del usuario (owner) => u
      - representación del grupo => g
      - representación del world => o
      - representación de todos => a, también se puede omitir el uso y el sistema interpretara que es para todos
      - agregar permisos al archivo => (u|g|o|a)+(r|w|x)
      - eliminar permisos al archivo  => (u|g|o|a)-(r|w|x)
      - poner los permisos tal cual se indican => (u|g|o|a)=(r|w|x), eliminara y agregara los permisos para tenerlo igual
      - multiples especificaciones pueden ser separadas por comas => permiso, permiso
   - controlar los permisos por defecto cuando se crea un archivo => umask valor
   - permisos especiales =>
     - sticky bit => conmumente usado para directorios nos dan la forma en que solo el owner y el superusuario
      chmod 1775 archivo_o_directorio o chmod +t archivo_o_directorio
    - bit SUID => el que ejecute va a tener los mismos permisos que el que creó el archivo, con cuidado porque puede acarrear problemas de seguridad
      chmod 4775 archivo o chmod u+s archivo
    - bit SGID => el que ejecute va a tener los mismos permisos que el grupo, util cuando se quiere configurar un directorio para colaborar con diferentes usuarios,
                  el archivo que cree el usuario tendra los permisos del grupo que pertenece el directorio y no del grupo del usuario
      chmod 2555 archivo_o_directorio o chmod g+s archivo_o_directorio
  - ejecutar un shell con un diferente usuario y grupo id's => su nombre_usuario
    - iniciar sesión con usuario diferente => su-l nombre_usuario, con el usuario root 'su -'
    - ejecutar comando en el new shell => su -c 'comando', siempre tiene que estar el comando entre ''
  - ejecutar comandos como otro usuario => sudo comando
    - cambiar los permisos específicos de usuarios particulares configurando => /etc/sudoers
  - la diferencia entre su y sudo => sudo no inicia un nuevo shell ni carga un entorno de otro usuario
    - listar los permisos del usuario => sudo -l
  - cambiar el propietario y grupo del archivo o directorio => chown
    - cambiar el archivo a un usuario determinado => chown user archivo
    - cambiar el archivo a un grupo determinado => chown :grupo archivo
    - cambiar el archivo a un usuario y grupo determinado => chown user:group archivo
    - cambiar el archivo a un usuario con su grupo por defecto en login => chown user: archivo
  - en versiones antiguas de Linux para poder cambiar el grupo del archivo => chgrp group archivo
  - cambiar contraseña de usuario => passwd user, usa strong password por lo cual valida que no sea muy corta, similar a la anterior o una palabra de diccionario
    - agregar al usuario es únicamente si tienes privilegios sino únicamente => passwd, que cambiará tu propia contraseña

--------------------------------------- DEFINITIONS ---------------------------------------

everything is a file => es una de las características de Unix donde maneja todo como si fuera un archivo

boot loader => programa encargado de cargar el kernel con los parametros opcionales del kernel a la memoria
  - GNU Grub
  - Linux Loader (LILO)
  - Load Linux (LOADLIN)

inode number => contiene los metadatos de un archivo (tamaño, permisos, fecha de creación, propietario, ...)

pagers => programas que permiten ver archivos de texto largos en un manejador de páginas

hard link (versión antigua) => permite múltples nombres referenciando un archivo, permite hacer cambios en todos los archivos relacionados pero tiene limitaciones
  - no se puede referenciar al link si no existe en el mismo sistema de archivos (referencia a la misma partición)
  - no se puede referenciar un directorio
  - cuando se elimina el archivo base se mantiene los archivos links

symbolic link (versión moderna) => permite múltiples nombres referenciando un archivo, permite hacer cambios en todos los archivos relacionados y en el archivo base permite

--------------------------------------- SHELLS ---------------------------------------

C Shell (csh) => es un intérprete de comandos de Unix
  - instalar en Debian => apt-get install csh





// esto es en etc
rc: no es tipicamente usando en distribuciones Linux, pero es usado en BSD (derivado de Linux)
rc.local: es usado para habilitar la ejecución de comandos adicionales al iniciarse sin tener que agregar symlinks (indica un acceso a un directorio)
rc.sysinit: es especifico de Red Hat y se ejecuta como uno de los primeros scripts, a diferencia de rc.local que se ejecuta más tarde

vmlinux: archivo ejecutable enlazado estáticamente y que contiene el núcleo Linux

crear grupo y usuario => sudo groupadd -g valor nombre_grupo

eliminar grupo => groupdel nombre_grupo

crear usuario => sudo useradd nombre_usuario

eliminar usuario => sudo userdel nombre_usuario

cambiar contraseña 'sudo passwd nombre_usuario'

ping [direccion] => para ver si nos manda respuesta la direccion IP

escribir en un archivo el STDOUT sin importar si es correcto o un error => comando >& nombre_archivo

nautilus => abrir directorio en el gui

ver los grupos => cat /etc/group

listar los grupos => groups

buscar palabras en un archivo => grep busqueda nombre_archivo
  - grep -i => para eliminar el case-sensitive
  - grep -n => para indicar la línea de donde se encontró
  - grep -c => para mostrar la cantidad de lineas que contienen la palabra parecida
  - grep -v => para mostrar todas las líneas que no tienen esta palabra

// BASH SCRIPTING

ver todos los shells disponibles => cat /etc/shells

para ver el bash actual => which bash

agregar texto dentro de un archivo => cat < archivo

concatenar mas texto dentro de un archivo => cat << archivo

comentar múltiples lineas => : ' lineas '

comparaciones =>
  - para poder usar los shortcuts es entre [] sino para usar los normales (())
  - dependiendo de la cantidad de condicionales se agrega []
  - en lugar de usar && se puede usar -a
  - en lugar de usar || se puede uasr -o
  - comparaciones de números
    - numero -eq numero2 => comprobar si los números son iguales
    - numero -ge numero2 => comprobar si el primer número es mayor o igual al segundo
    - numero -gt numero2 => comprobar si el primer numero es mayor al segundo
    - numero -le numero2 => comprobar si el primer numero es menor o igual al segundo
    - numero -lt numero2 => comprobar si el primer numero es menor al segundo
    - numero -ne numero2 => comprobar si el primer numero es diferente al segundo

case statement =>
  case $variable in
    "VALUE" )
      lineas de código ;;

todos las keywords para terminar es la palabra al revés

crear un rango => {inicial..final..incremento}

crear for condition => for in {rango} ó for (( como un for normal ))

args=("$@") =>  es una forma de pedir cuantos argumentos sean necesarios

ver la cantidad de argumentos => $#

case string =>
  - ${variable^} => capitalize
  - ${variable^^} => upcase

realizar operaciones => expr operacion

verificar si existe el directorio => -d "$direct_name"

verificar si existe el archivo => -f "$file_name"

crear un menú seleccionable => select variable in VALUE VALUE VALUE ..
                               do
                                 comandos
                               done
para leer cada cierto tiempo => read -t cantidad

comprobar que el tiempo de espera ha terminado => $? = 0

para debuguear => bash -x archivo_ejecutable

CENTOS

para poder ver el DNS => /etc/resolv.conf

configurar la IP a estática => dentro del archivo de ip /etc/sysconfig/network-scripts/nombre-archivo
  - cambiando el tipo => BOOTPROTO=static
  - IPADDR=ip => cambiar el IP
  - NETMAKS=255.255.255.0 => cambiar la máscara de red
  - GATEWAY=punto-salida => cambiar el punto de salida de la ip
  - DNS1=valor => cambiar el valor de la DNS con el valor de /etc/resolv.conf

modificar DNS => /etc/named.conf

configurar bind => /usr/share/doc/bind-9.9.4/sample/etc/named.rfc1912.zones
  - cuando se modifica también se deben crear los archivos correspondientes los cuales contendrán los registros de recursos (entradas para resolver los nombres)
    estos archivos son directos e indirectos:
      - /usr/share/doc/bind-9.9.4/sample/etc/named.localhost hacia => /var/named/upao.directa
      - /usr/share/doc/bind-9.9.4/sample/etc/named.loopback hacia => /var/named/upao.indirecta
  - comprobar que el named ha sido cambiado => named-checkzone name_dns /var/named/upao.directa
  - verificar si la sintaxis esta bien => named-checkconf /etc/named.conf
  - verificar si esta funcionando la conexion DNS => dig name_dns DNS






//
modificar los hosts => en el archivo /etc/hosts

manejar las particiones => fdisk /dev/sda

ver la formación de las particiones => lsblk

formatear particiones =>
  - a ext4 => mkfs.ext4 /dev/particion
  - para swap =>
    - configurar para swap = mkswap /dev/particion
    - habilitar archivos para pagination y swapping => swapon /dev/particion

montar una particion => mount /dev/particion /mnt/directorio

instalar el paquete base (contiene los paquetes necesario para usar el sistema, librerías C, Bash Shell, etc.) para arch linux => pacstrap /mnt base base-devel

generar un fstab file para definir como las particiones, block devices o archivos remotos del sistema son montados dentro del filesystem => genfstab -U /mnt >> /mnt/etc/fstab

cambiar el root dentro del nuevo sistema para el proceso actual ejecutandose y el proceso hijo => arch-chroot /mnt

configurar la zona horaria:
  - crear un symbolic link que se usará al iniciar el sistema => ln -sf /usr/share/<zoneinfo>/<Region>/<City> /etc/localtime
  - configurar el hardware clock => hwclock --systohc --utc

configurar el idioma:
  - descomentar el idioma que se usará en /etc/locale.gen => vi /etc/locale.gen
  - setear el locale =>
    locale-gen
    echo LANG=es_PE.UTF-8 > /etc/locale.conf
    export LANG=es_PE.UTF-8
say => convertir texto en audio usando GNUstep speech engine

festival => convertir texto en audio
  con este paquete viene instalado text2wave => convertidor de texto a .wav files
    - guardar como .wav file => text2wave -o archivo.wav

procesos =>
  - listar los procesos => ps
    - listar todos los procesos independientemente de la terminal en que se encuentre => ps x
    - listar todos los procesos con más detalles independientemente de la terminal => ps aux
    - estados de los procesos =>
      - ejecutandos o listo para empezar => R (running)
      - el proceso no esta corriendo y está a la espera de un evento => S (sleep)
      - el proceso está esperando una I/O como un disco duro => D (uninterruptible sleep)
      - el proceso ha sido detenido => T (stopped)
      - proceso difunto o 'zombie', es un proceso hijo finalizado pero que el padre no ha limpiado => Z
      - proceso de alta prioridad, es posible darle más importancia al agregarle al proceso más tiempo, esta propiedad del proceso se llama amabilidad, pero se dice que es
        menos agradable porque toma más tiempo de la CPU, dejando menos para todos los demás => <
      - un proceso de baja prioridad (buen proceso) obtendrá tiempo del procesador una vez que se terminen los procesos de alta prioridad => N
  - listar los procesos de manera dinámica (continuamente actualizandose), ordenandose por la actividad del CPU => top
  - listar los jobs que han sido lanzados desde la terminal, se verán los procesos background lanzados por la terminal => jobs
  - poner en background el proceso => comando &, el output del comando nos indica el PID
    - si el proceso ya existe => bg %job_number
  - retornar un proceso al foreground => fg %job_number
  - poner en pausa un proceso => CTRL + Z, cuando se esta ejecutando el proceso lo cual manda una señal llamada TSTP (terminal stop)
  - terminar un proceso en foreground => CTRL + C, envia una señal llamada INT (interrupt)
  - terminar procesos mandando señales => kill [-signal] PID o kill %job_number, cuando no se especifica el signa toma el valor TERM
    - HUP (hang up), cuando se cierra una terminal y los procesos en foreground terminan => 1
    - INT (interrupt), termina el programa, tiene la misma funcionalidad que CTRL + C => 2
    - KILL (kill), sería el último recurso para terminar un proceso porque lo realiza directamente desde el kernel => 9
    - TERM (terminate), es el valor por defecto, termina el proceso => 15
    - CONT (continue), restaura el proceso después de una señal de STOP => 18
    - STOP (stop), detiene el proceso sin terminarlo => 19
  - eliminar multiples proceso => killall [-u user] [-signal] name|PID
  - mostrar una lista de los procesos ordenados de padre-hijos => pstree
  - mostrar un snapshot de los recursos del sistema como memoria, swap, y disk I/O => vmstat
    - indicar el tiempo (en segundos) de actualización de los recursos => vmstat tiempo
  - programa gráfico que muestra un grafo con la carga del sistema => xload
  - mostrar un grafo en la terminal donde se muestre la carga del sistema => tload

ventajas de lanzar un programa gráfico desde la consola =>
  - el programa no está listada como opciones en el menú
  - podemos ver los errores que lanza el programa en la consola

tmux => es un mutiplexor de terminal que permite dividir la consola
  - instalar => sudo apt-get install tmux
  - crear una nueva session con su nombre => tmux new -s nombre_consola
  - hacer un split vertical => CTRL + B %
  - hacer un split horizontal => CTRL + B "
  - eliminar panel actual => CTRL + B X

solucionar error input/output usb =>
  - instalar librería => sudo apt-get install dosfstools
  - desmontar el usb => sudo umount /dev/sdb1
  - reparar usb => sudo dosfsck -t -a -w /dev/sdb1

diferencias entre apt & apt-get =>
  apt-get =>
    - solamente actualiza los repositorios no da mayor información
  apt =>
    - da información adicional cuando se realizan actualizaciones
    - mejores opciones para el manejo de repositorios
  - recomendación => usar apt en lugar de apt-get

==================================================================================================================================================================
ENVIRONMENT

environment variables => son todas las variables que no son creadas por el bash
  - DISPLAY => el nombre de la pantalla si se está ejecutando una interfaz gráfica
  - EDITOR => nombre del programa que se usará como editor de texto
  - SHELL => el nombre del shell program
  - HOME => el pathname del directorio home
  - LANG => define el conjunto de caracteres y orden de colación del lenguaje
  - OLD_PWD => el directorio de trabajo previo
    - en Zorin OS => OLDPWD
  - PAGER => nombre del programa usado para paginar los output
  - PATH => la lista de directorios en los que se busca cuando pones el nombre de un programa ejecutable, separados por :
    - se indica en los diferentes startup files
  - PS1 => define el contenido del shell prompt
  - PWD => directorio actual de trabajo
  - TERM => el nombre del tipo de terminal
  - TZ => especifíca el time zone
  - USER => nombre del usuario actual
  - HISTCONTROL => controlar el comando history
    - ignoredups => indica que se ignorarán los comandos que ya han sido grabados
  - HISTSIZE => controlar el tamaño de lineas que recuerda el comando history, se le puede cambiar el número que por default son 500

shell variables => son bits de datos colocados por bash, también guarda aliases y shell functions

mostrar los environment variables => printenv, también se puede mostrar el valor directamente de una variable printenv VARIABLE

mostrar todas las variables => set

alias => es un comando que podemos definir nosotros mismos
  - crear un alias => alias nombre_alias='comandos'
  - eliminar alias => unalias nombre_alias

ver todos los alias creados => alias

startup files =>
  - login shell session => es el prompt solicita nuestro usuario y contraseña
    - script de configuración que aplica a todos los usuarios => /etc/profile
    - script de configuración personal, se usa para extender o sobreescribir las configuraciones globales => ~/.bash_profile, para definir las environment variables usar este archivo
    - si no es encuentra .bash_profile, se lee el siguiente archivo => ~/.bash_login
    - si no se encuentra .bash_profile ni .bash_login, se lee el siguente archivo => ~/.profile
  - non-login shell session => normalmente cuando iniciamos una sesion de terminal en la GUI
    - script de configuración que se aplica a todos los usuarios => /etc/.bash.bashrc
    - script de configuración personal por usuarios => ~/.bashrc, para todas las configuraciones que no tengan que ver con las environment variables
  - los non-login startup files heredan el environment de los login shell startup files

indicar que la variable será usado en los procesos del shell actual => export VARIABLE

extensiones comunes para backups => .bak, .sav, .old, .orig

hacer que un startup file lea sus cambios sin necesidad de reiniciar el shell => source .nombre_startup_file

--------------------------------------- BASH ---------------------------------------

comentarios => #
if compound command =>
  if [ condicion ]; then
    funcionalidad
  fi

comprobar si existe archivo => -f nombre_archivo

leer archivo => . nombre_archivo

--------------------------------------- VIM ---------------------------------------

entrar en insert mode => i
salir del archivo => :q
guardar el archivo => :w
  - guardar en un archivo aparte => :w nombre_archivo
ir al inicio del archivo => gg
ir al final del archivo => G
ir al inicio o fin de un bloque => { }
se puede indicar la cantidad que se realizará el comando => numero (comando)
cortar una linea entera => dd
  - se pueden indicar más maneras de cuantas líneas se cortaran => d(comando)
deshacer los cambios => u
retrocer cuando se deshace el cambio => CTRL + R
copiar una linea => yy
pegar => p
  - pegar detrás de la línea del cursor => SHIFT + P
entrar en insert mode agregando una nueva línea => o
entrar en visual mode => v
inicio de siguiente palabra => w
  - moverse al inicio de siguiente palabra después del próximo espacio en blanco => W
fin de siguiente palabra => e
  - moverse al fin de siguiente palabra después del próximo espacio en blanco => E
inicio de anterior palabra => b
  - moverse a la anterior palabra después del anterior espacio en blanco, ignorando signos de puntuación => B
moverse al inicio de la línea => 0
moverse al final de la línea => $
ir exactamente a la letra que se busca => f (letra)
ir un espacio anterior a la letra que se busca => t (letra)
  - ir a la siguiente coincidencia de la línea => ;
mover al inicio o fin de () [] {} => %
cambiar una cantidad => c (comando)
buscar la siguiente palabra igual => *
entrar en insert mode al final de la linea => A
eliminar la letra de la derecha => x
  - se puede indicar otro comando para indicar el límite de eliminación => x (comando)
cambiar el case de la letra => ~
  - indicar la cantidad letras que cambiará el case => (numero) ~
ejecutar el mismo comando anterior (period) => .
reemplazar la letra actual => r
  - indicar cuantas letras se cambiaran => (numero) r
cambiar toda la línea => R
entrar en modo modo visual seleccionando una línea => CTRL + V
entrar en modo modo visual seleccionando un bloque => SHIFT + V
identar para la derecha => >
indentar para la izquierda => <
crear macros para agrupar comandos => q (letra), llamar macro @(letra)
realizar un cambio a múltiples líneas => después de CTRL + V usar SHIFT + I y podremos agregar múltiples texto en todo el bloque seleccionado
descender una página => SHIFT + F
ascender una página => SHIFT + B
unir dos líneas => :j
busqueda global y reemplazamiento => rangooperacion/texto/texto/gc
  - rango =>
    - todo el archivo => %
    - desde una línea hasta el final del archivo => numero_linea,$
  - operacion =>
    - indicar sustitución => s
  - /texto/texto/ => el primero es texto que se reemplazará y el segundo es el texto con el que se reemplazará
  - g => indica que se hará el cambio de manera global, si se omite solamente se hará al primero que encuentre
  - c => es opcional, indica la confirmación del usuario antes de cada sustitución
    - aceptar el cambio en la instancia => y
    - saltear el cambio en la instancia => n
    - realizar el cambio a partir de la instancia actual para las siguientes => a
    - salir de sustitución manteniendo los cambios anteriores => q
    - realizar la sustitución de la instancia actual y salir => l
    - moverse entre las instancias => arriba CTRL + E, abajo CTRL + Y
se pueden abrir múltiples archivos => vi archivo archivo archivo
  - pasar al siguiente archivo => :n
  - pasar al archivo anterior => :N
  - ver la lista de archivos que fueron editados => :buffers
  - cambiar exactamente a un archivo => :buffer numero_archivo
indicar el archivo que se editará => :e nombre_archivo
insertar todo el contenido de otro archivo en el archivo actual, lo insertará arribar del cursor => :r nombre_archivo
guardar y salir del archivo actual => ZZ
autocompletar la palabra => en insert mode, CTRL + n
mostrar los números de línea => :set number
ocultar los número de línea => :set nonumber
NERDTree => plugin para poder utilizar un menú de todos los archivos
  - split de manera horizontal => i
  - split de manera vertical => s
  - refrescar los archivos =>
    - solamente el directorio actual => r
    - desde el root => R
  - cambiar el ancho del split => ctrl + w + cantidad + >|<
    - indicando la cantidad para ver cuanto espacio mover
  - abrir en un nuevo tab => T
    - moverse al siguiente tab => gt
    - retroceder de tab => gT
  - mostrar archivos ocultos => shift + i
buscar una palabra => /palabra
  - buscar una palabra sin case sensitive => /palabra\c
ejecutar comandos => :! comando
manejar líneas de código =>
  - ocultar lo seleccionado => zf
  - mostrar lo seleccionado => zD
